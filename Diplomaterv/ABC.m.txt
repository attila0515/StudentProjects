    function [vd,vq] = ABC(i_ref,idq,omega)
        persistent v_old Ls Rs psi_s Ts Vdc idmax iqmax radius
    
        if isempty(v_old) 
            v_old = zeros(2,1); 
            Ls = 0.32e-3; % H
            Rs = 0.285; % ohm
            psi_s = 0.0079; % Vs
    
            % Sampling time
            Ts = 1e-4; % s
        
            % DC voltage
            Vdc = 24; % V
    
            idmax = 1;
            iqmax = 4;
    
            radius = Vdc/sqrt(3);
        end
        
        vd = v_old(1);
        vq = v_old(2);
    
        iprev = [idq(1); idq(2)]; % measured currents
        
        % Prediction
        % x[k+1] = A*x[k]+B*u[k]+d
        % Matrices
        A = [1-Ts*Rs/Ls, omega*Ts; -omega*Ts, 1-Ts*Rs/Ls];
        B = Ts/Ls*eye(2);
        d = [0 -omega*Ts*psi_s/Ls]';
    
        % k+1
        ik_p1 = A*iprev+B*[v_old(1);v_old(2)]+d;
    
        % Initialization
        popSize = 10;
        iter = 12;
        limit = 7;
    
        population = generatePoints(radius,popSize);
        
        fitness = CostFunction(population,ik_p1,i_ref,A,B,d,idmax,iqmax);
        trial = zeros(1,popSize); % unsuccessfull trial
    
        for j=1:iter
            % Employed bees
            for i = 1:popSize
                neighbour = generateNeighbour(population, radius, i);
                neighbourFitness = CostFunction(neighbour,ik_p1,i_ref,A,B,d,idmax,iqmax);
                    
                % Greedy Selection
                if neighbourFitness < fitness(i)
                   population(:,i) = neighbour;
                   fitness(i) = neighbourFitness;
                   trial(i) = 0;
                else
                   trial(i) = trial(i) + 1; % no better neighbour was found
                end
            end
        
            % Onlooker bees
            prob = fitnessSelection(fitness);
            for i = 1:popSize
                if rand < prob(i) % rand returns value in range [0,1]
                   neighbour = generateNeighbour(population, radius, i);
                   neighbourFitness = CostFunction(neighbour,ik_p1,i_ref,A,B,d,idmax,iqmax);
                        
                   % Greedy Selection
                   if neighbourFitness < fitness(i)
                      population(:,i) = neighbour;
                      fitness(i) = neighbourFitness;
                      trial(i) = 0;
                   else
                      trial(i) = trial(i) + 1;
                   end
                end
            end
          
            % Scout bees
            for i = 1:popSize
                if trial(i) > limit % if a food is not improved for too long, it is replaced
                   population(:,i) = generatePoints(radius,1);
                   fitness(i) = CostFunction(population(:,i),ik_p1,i_ref,A,B,d,idmax,iqmax);
                   trial(i) = 0;
                end
            end
            [bestValue, bestIdx] = min(fitness);
            bestSolution = population(:, bestIdx);
        end
        v_old = bestSolution;
    end
    
    % Generate Neighbour Solution
    function neighbour = generateNeighbour(population, radius, i)
        popSize = size(population, 2);
        dim = size(population, 1); % dimension of search space
        
        k = randi(popSize); %random integer between 1 and popSize
        while k == i % regenerate if two indexes are equal
            k = randi(popSize);
        end
        % irány a szomszéd felé
        direction = -population(:, i) + population(:, k);
        direction = direction./norm(direction + 0.001);  % unit vector
    
        %phi = -1 + 2 * rand(dim, 1); % Random number in range [-1,1]
        neighbour = population(:, i) +0.27*radius*direction;%+ phi .* (population(:, i) - population(:, k));
        
        % Bound check
        if norm(neighbour) > radius % falls outside of the circle, fit to the contour
           neighbour =  neighbour./norm(neighbour)*radius;
        end
    end
    
    %Selection Probabilities
    function prob = fitnessSelection(fitness)
        dim = size(fitness,2);
        f_inv = zeros(1,dim); 
        for i=1:dim
            if fitness(i) >= 0
               f_inv(i) = 1 ./ (1 + fitness(i));
            else
               f_inv(i) = 1+abs(fitness(i));
            end
        end
        prob = f_inv / sum(f_inv); % Normalize to get probabilities
    end
    
    % Point Generator
    function points = generatePoints(R,numPoints)
        xp = (2 * rand(2,numPoints) - ones(2,numPoints)) * R; % generate within a square , 2R side length
        for i=1:numPoints
            while (norm(xp(:,i)) > R)
                xp(:,i) = (2 * rand(2,1) - ones(2,1)) * R; % regenerate
            end
        end
        points = xp;
    end
    
    % Cost function
    function g = CostFunction(v,ik1,iref,A,B,d,idmax,iqmax)
        idmax = 1;
        iqmax = 4;
        ik2 = A*ik1+B*v+d;
        g = (iref-ik2(2,:)).^2+ik2(1,:).^2+ 10000 * (abs(ik2(2,:)) > iqmax) + 10000* (abs(ik2(1,:)) > idmax);
    end